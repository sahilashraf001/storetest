
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview AI-powered product recommendations.
 *
 * - recommendProducts - A function that provides product recommendations.
 * - RecommendProductsInput - The input type for the recommendProducts function.
 * - RecommendProductsOutput - The return type for the recommendProducts function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const RecommendProductsInputSchema = z.object({
  currentProductId: z
    .string()
    .optional()
    .describe('The ID of the product currently being viewed by the user.'),
  currentProductCategory: z
    .string()
    .optional()
    .describe('The category of the product currently being viewed.'),
  currentProductName: z
    .string()
    .optional()
    .describe('The name of the product currently being viewed.'),
  viewingHistory: z
    .array(z.string())
    .optional()
    .describe('An array of product IDs representing the user viewing history.'),
  availableProductIds: z
    .array(z.string())
    .describe('A list of all available product IDs in the catalog that can be recommended. This list should NOT include the currentProductId.'),
  maxRecommendations: z
    .number()
    .default(4)
    .describe('The maximum number of product recommendations to return.'),
});
export type RecommendProductsInput = z.infer<typeof RecommendProductsInputSchema>;

const RecommendProductsOutputSchema = z.object({
  productRecommendations: z
    .array(z.string())
    .describe('An array of distinct product IDs for recommendation, excluding the currentProductId.'),
});
export type RecommendProductsOutput = z.infer<typeof RecommendProductsOutputSchema>;

export async function recommendProducts(input: RecommendProductsInput): Promise<RecommendProductsOutput> {
  return recommendProductsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'recommendProductsPrompt',
  input: {schema: RecommendProductsInputSchema},
  output: {schema: RecommendProductsOutputSchema},
  prompt: `You are a product recommendation expert for a CCTV security product website.
Your goal is to recommend products from the 'availableProductIds' list.
Do NOT include the 'currentProductId' (if provided) in your recommendations.
The list of available product IDs for you to choose from is: {{#each availableProductIds}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}.

{{#if currentProductId}}
You are currently on the product page for '{{currentProductName}}' (ID: {{currentProductId}}) in the '{{currentProductCategory}}' category.
Prioritize recommending products that are similar, complementary, or good alternatives to this specific product.
Consider its features and category.
{{else}}
You are generating general product recommendations.
{{/if}}

{{#if viewingHistory}}
The user also has a general viewing history of these product IDs: {{#each viewingHistory}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}.
You can use this history as secondary context if it helps in making more relevant suggestions, especially if not focusing on a current product.
{{else}}
No specific general viewing history provided by the user.
{{/if}}

Based on the information above, provide up to {{maxRecommendations}} distinct product IDs from the 'availableProductIds' list.
Ensure your output is only a list of product IDs.
`,
});

const recommendProductsFlow = ai.defineFlow(
  {
    name: 'recommendProductsFlow',
    inputSchema: RecommendProductsInputSchema,
    outputSchema: RecommendProductsOutputSchema,
  },
  async input => {
    // Ensure availableProductIds does not contain currentProductId before sending to LLM
    const filteredAvailableProductIds = input.currentProductId
      ? input.availableProductIds.filter(id => id !== input.currentProductId)
      : input.availableProductIds;

    if (filteredAvailableProductIds.length === 0) {
      return { productRecommendations: [] };
    }

    const {output} = await prompt({ ...input, availableProductIds: filteredAvailableProductIds });
    
    if (output?.productRecommendations) {
      // Further ensure currentProductId is not in the output and recommendations are distinct
      const distinctRecommendations = Array.from(new Set(output.productRecommendations));
      const finalRecommendations = input.currentProductId
        ? distinctRecommendations.filter(id => id !== input.currentProductId)
        : distinctRecommendations;
      return { productRecommendations: finalRecommendations.slice(0, input.maxRecommendations) };
    }
    return { productRecommendations: [] };
  }
);
